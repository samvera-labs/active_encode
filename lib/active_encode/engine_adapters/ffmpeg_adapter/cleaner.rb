# frozen_string_literal: true
module ActiveEncode
  module EngineAdapters
    class FfmpegAdapter
      module Cleaner
        # This method is to clean up files leftover from the ffmpeg encode process.
        # File names for the pass_through adapter are the same, so this will clean up
        # pass_through encodes as well.
        def remove_old_files!(options = {})
          default_options = {
            older_than: 2.weeks,
            no_outputs: ['input_metadata', 'duration_input_metadata', 'error.log', 'exit_status.code', 'progress', 'completed', 'pid', 'output_metadata-*'],
            outputs: false,
            all: false
          }
          options.reverse_merge!(default_options)

          if options[:all]
            files = build_file_list(WORK_DIR, "*")
            directories = remove_files(files, options[:older_than])
            remove_empty_directories(directories)
          elsif options[:outputs]
            output_directories = build_file_list(WORK_DIR, "outputs")
            remove_child_files(output_directories, options[:older_than])
            remove_empty_directories(output_directories)
          else
            files = []
            options[:no_outputs].each { |fn| files += build_file_list(WORK_DIR, fn) }
            remove_files(files, options[:older_than])
          end
        end

        def build_file_list(directory, filename)
          file_path = File.join(directory, "**", filename)
          # Some of the files generated by the ffmpeg encode seem to be hidden files.
          # This uses File::FNM_DOTMATCH to include them in the results.
          Dir.glob(file_path, File::FNM_DOTMATCH)
        end

        def file_check(path, older_than)
          File.mtime(path) < DateTime.now - older_than && File.file?(path)
        end

        def remove_files(files, older_than)
          files_to_delete = files.select { |f| file_check(f, older_than) }
          FileUtils.rm(files_to_delete) unless files_to_delete.empty?

          # Return a list of any directories that were included in the files list for further processing.
          # The files list can include directories such as "/tmp/.." which should not be included in directory list.
          files.select { |f| File.directory?(f) unless f.end_with?(".") }
        end

        def remove_empty_directories(directories)
          directories_to_delete = directories.select { |d| Dir.empty?(d) }
          non_empty_directories = directories - directories_to_delete
          directories_to_delete += non_empty_directories.select do |ned|
            Dir.children(ned).sort == ["outputs", "supplemental_files"] &&
              directories_to_delete.include?(File.join(ned, "outputs")) &&
              directories_to_delete.include?(File.join(ned, "supplemental_files"))
          end
          FileUtils.rmdir(directories_to_delete) unless directories_to_delete.empty?
        end

        def remove_child_files(directories, older_than)
          files_to_delete = []
          directories.each do |d|
            files = Dir.children(d).select { |ch| file_check(File.join(d, ch), older_than) }
            files_to_delete += files.collect { |f| File.join(d, f) }
          end
          FileUtils.rm(files_to_delete) unless files_to_delete.empty?
        end
      end
    end
  end
end
